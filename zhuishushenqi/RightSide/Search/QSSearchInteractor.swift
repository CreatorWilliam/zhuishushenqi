//
//  QSSearchInteractor.swift
//  zhuishushenqi
//
//  Created caonongyun on 2017/4/10.
//  Copyright © 2017年 QS. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import QSNetwork

class QSSearchInteractor: QSSearchInteractorProtocol {

    weak var output: QSSearchInteractorOutputProtocol!
    var hotwords:[String] = []
    var offset:Int = 0
    
    private let SearchStoreKey = "SearchHistory"

    func fetchHotwords(){
        QSNetwork.request(QSHotwords.QSSearchWords.fetch(id: "").staURL) { (response) in
            QSLog(response.json)
            if let hotwords:[String] = response.json?["hotWords"] as? [String] {
                self.hotwords = hotwords
                self.output.fetchHotwordsSuccess(hotwords: self.subWords())
            }else{
                self.output.fetchHotwordsFailed()
            }
        }
    }
    
    func fetchSearchList(){
        var list:[[String]] = []
        let hot:[String] = []
        var history:[String] = []
        history = getHistoryList()
        list.append(hot)
        list.append(history)
        self.output.searchListFetch(list: list)
    }
    
    func clearSearchList(){
        let store = getHistoryStore()
        let list:[[String]] = [[],[]]
        store?.clearTable(searchHistory)
    
        self.output.searchListFetch(list: list)
    }
    
    func updateHistoryList(history:String){
        var list = getHistoryList()
        if !isExistSearchWord(key: history, historyList:list) {
            let store = getHistoryStore()
            list.append(history.trimmingCharacters(in: CharacterSet(charactersIn: " ")))
            store?.clearTable(searchHistory)
            store?.put(list, withId: SearchStoreKey, intoTable: searchHistory)
            self.output.searchListFetch(list: [ [],list])
        }
    }
    
    func fetchBooks(key:String){
        let url = "\(BASEURL)/book/fuzzy-search"
        let param = ["query":"\(key)","start":"0","limit":"100"]
        QSNetwork.request(url, method: HTTPMethodType.get, parameters: param, headers: nil) { (response) in
            do{
                if let books = response.json?.object(forKey: "books") {
                    let booksModel:[Book] = try XYCBaseModel.model(withModleClass: Book.self, withJsArray:books as! [AnyObject]) as! [Book]
                    self.output.fetchBooksSuccess(books: booksModel,key:key)
                }else{
                    self.output.fetchBooksFailed(key: key)
                }
            }catch{
                QSLog(error)
            }
        }
    }
    
    func getHistoryList()->[String]{
        let store = getHistoryStore()
        return store?.getObjectById(SearchStoreKey, fromTable: searchHistory) as? [String] ?? []
    }
    
    func getHistoryStore()->YTKKeyValueStore?{
        let store  = YTKKeyValueStore(dbWithName: dbName)
        if store?.isTableExists(searchHistory) == false {
            store?.createTable(withName: searchHistory)
        }
        return store
    }
    
    
    func isExistSearchWord(key:String,historyList:[String])->Bool{
        var isExist = false
        for item in historyList {
            if item == key {
                isExist = true
            }
        }
        return isExist
    }
    
    func subWords()->[String]{
        var subWords:[String] = []
        for item in offset..<offset+6 {
            subWords.append(hotwords[item%hotwords.count])
        }
        offset += 6
        return subWords
    }
}
